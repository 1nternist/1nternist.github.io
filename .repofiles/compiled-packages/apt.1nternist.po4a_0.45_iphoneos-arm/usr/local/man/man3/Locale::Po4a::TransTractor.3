.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Po4a::TransTractor 3"
.TH Locale::Po4a::TransTractor 3 "2015-01-23" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Po4a::TransTractor \- generic trans(lator ex)tractor.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The po4a (\s-1PO\s0 for anything) project goal is to ease translations (and more
interestingly, the maintenance of translations) using gettext tools on
areas where they were not expected like documentation.
.PP
This class is the ancestor of every po4a parser used to parse a document, to
search translatable strings, to extract them to a \s-1PO\s0 file and to replace them by
their translation in the output document.
.PP
More formally, it takes the following arguments as input:
.IP "\-" 2
a document to translate;
.IP "\-" 2
a \s-1PO\s0 file containing the translations to use.
.PP
As output, it produces:
.IP "\-" 2
another \s-1PO\s0 file, resulting of the extraction of translatable strings from
the input document;
.IP "\-" 2
a translated document, with the same structure than the one in input, but
with all translatable strings replaced with the translations found in the
\&\s-1PO\s0 file provided in input.
.PP
Here is a graphical representation of this:
.PP
.Vb 6
\&   Input document \-\-\e                             /\-\-\-> Output document
\&                     \e                           /       (translated)
\&                      +\-> parse() function \-\-\-\-\-+
\&                     /                           \e
\&   Input PO \-\-\-\-\-\-\-\-/                             \e\-\-\-> Output PO
\&                                                         (extracted)
.Ve
.SH "FUNCTIONS YOUR PARSER SHOULD OVERRIDE"
.IX Header "FUNCTIONS YOUR PARSER SHOULD OVERRIDE"
.IP "\fIparse()\fR" 4
.IX Item "parse()"
This is where all the work takes place: the parsing of input documents, the
generation of output, and the extraction of the translatable strings. This
is pretty simple using the provided functions presented in the section
\&\fB\s-1INTERNAL\s0 \s-1FUNCTIONS\s0\fR below. See also the \fB\s-1SYNOPSIS\s0\fR, which presents an
example.
.Sp
This function is called by the \fIprocess()\fR function below, but if you choose
to use the \fInew()\fR function, and to add content manually to your document,
you will have to call this function yourself.
.IP "\fIdocheader()\fR" 4
.IX Item "docheader()"
This function returns the header we should add to the produced document,
quoted properly to be a comment in the target language.  See the section
\&\fBEducating developers about translations\fR, from \fIpo4a\fR\|(7), for what
it is good for.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The following example parses a list of paragraphs beginning with \*(L"<p>\*(R". For the sake
of simplicity, we assume that the document is well formatted, i.e. that '<p>'
tags are the only tags present, and that this tag is at the very beginning
of each paragraph.
.PP
.Vb 2
\& sub parse {
\&   my $self = shift;
\&
\&   PARAGRAPH: while (1) {
\&       my ($paragraph,$pararef)=("","");
\&       my $first=1;
\&       my ($line,$lref)=$self\->shiftline();
\&       while (defined($line)) {
\&           if ($line =~ m/<p>/ && !$first\-\-; ) {
\&               # Not the first time we see <p>.
\&               # Reput the current line in input,
\&               #  and put the built paragraph to output
\&               $self\->unshiftline($line,$lref);
\&
\&               # Now that the document is formed, translate it:
\&               #   \- Remove the leading tag
\&               $paragraph =~ s/^<p>//s;
\&
\&               #   \- push to output the leading tag (untranslated) and the
\&               #     rest of the paragraph (translated)
\&               $self\->pushline(  "<p>"
\&                               . $document\->translate($paragraph,$pararef)
\&                               );
\&
\&               next PARAGRAPH;
\&           } else {
\&               # Append to the paragraph
\&               $paragraph .= $line;
\&               $pararef = $lref unless(length($pararef));
\&           }
\&
\&           # Reinit the loop
\&           ($line,$lref)=$self\->shiftline();
\&       }
\&       # Did not get a defined line? End of input file.
\&       return;
\&   }
\& }
.Ve
.PP
Once you've implemented the parse function, you can use your document
class, using the public interface presented in the next section.
.SH "PUBLIC INTERFACE for scripts using your parser"
.IX Header "PUBLIC INTERFACE for scripts using your parser"
.Sh "Constructor"
.IX Subsection "Constructor"
.IP "process(%)" 4
.IX Item "process(%)"
This function can do all you need to do with a po4a document in one
invocation. Its arguments must be packed as a hash. \s-1ACTIONS:\s0
.RS 4
.IP "a." 3
.IX Item "a."
Reads all the \s-1PO\s0 files specified in po_in_name
.IP "b." 3
.IX Item "b."
Reads all original documents specified in file_in_name
.IP "c." 3
.IX Item "c."
Parses the document
.IP "d." 3
.IX Item "d."
Reads and applies all the addenda specified
.IP "e." 3
.IX Item "e."
Writes the translated document to file_out_name (if given)
.IP "f." 3
.IX Item "f."
Writes the extracted \s-1PO\s0 file to po_out_name (if given)
.RE
.RS 4
.Sp
\&\s-1ARGUMENTS\s0, beside the ones accepted by \fInew()\fR (with expected type):
.IP "file_in_name (@)" 4
.IX Item "file_in_name (@)"
List of filenames where we should read the input document.
.IP "file_in_charset ($)" 4
.IX Item "file_in_charset ($)"
Charset used in the input document (if it isn't specified, it will try
to detect it from the input document).
.IP "file_out_name ($)" 4
.IX Item "file_out_name ($)"
Filename where we should write the output document.
.IP "file_out_charset ($)" 4
.IX Item "file_out_charset ($)"
Charset used in the output document (if it isn't specified, it will use
the \s-1PO\s0 file charset).
.IP "po_in_name (@)" 4
.IX Item "po_in_name (@)"
List of filenames where we should read the input \s-1PO\s0 files from, containing
the translation which will be used to translate the document.
.IP "po_out_name ($)" 4
.IX Item "po_out_name ($)"
Filename where we should write the output \s-1PO\s0 file, containing the strings
extracted from the input document.
.IP "addendum (@)" 4
.IX Item "addendum (@)"
List of filenames where we should read the addenda from.
.IP "addendum_charset ($)" 4
.IX Item "addendum_charset ($)"
Charset for the addenda.
.RE
.RS 4
.RE
.IP "new(%)" 4
.IX Item "new(%)"
Create a new po4a document. Accepted options (but be in a hash):
.RS 4
.IP "verbose ($)" 4
.IX Item "verbose ($)"
Sets the verbosity.
.IP "debug ($)" 4
.IX Item "debug ($)"
Sets the debugging.
.RE
.RS 4
.RE
.Sh "Manipulating document files"
.IX Subsection "Manipulating document files"
.IP "read($)" 4
.IX Item "read($)"
Add another input document at the end of the existing one. The argument is
the filename to read.
.Sp
Please note that it does not parse anything. You should use the \fIparse()\fR
function when you're done with packing input files into the document.
.IP "write($)" 4
.IX Item "write($)"
Write the translated document to the given filename.
.Sh "Manipulating \s-1PO\s0 files"
.IX Subsection "Manipulating PO files"
.IP "readpo($)" 4
.IX Item "readpo($)"
Add the content of a file (which name is passed as argument) to the
existing input \s-1PO\s0. The old content is not discarded.
.IP "writepo($)" 4
.IX Item "writepo($)"
Write the extracted \s-1PO\s0 file to the given filename.
.IP "\fIstats()\fR" 4
.IX Item "stats()"
Returns some statistics about the translation done so far. Please note that
it's not the same statistics than the one printed by msgfmt
\&\-\-statistic. Here, it's stats about recent usage of the \s-1PO\s0 file, while
msgfmt reports the status of the file. It is a wrapper to the
Locale::Po4a::Po::stats_get function applied to the input \s-1PO\s0 file. Example
of use:
.Sp
.Vb 1
\&    [normal use of the po4a document...]
\&
\&    ($percent,$hit,$queries) = $document\->stats();
\&    print "We found translations for $percent\e%  ($hit from $queries) of strings.\en";
.Ve
.Sh "Manipulating addenda"
.IX Subsection "Manipulating addenda"
.IP "addendum($)" 4
.IX Item "addendum($)"
Please refer to \fIpo4a\fR\|(7) for more information on what addenda are,
and how translators should write them. To apply an addendum to the translated
document, simply pass its filename to this function and you are done ;)
.Sp
This function returns a non-null integer on error.
.SH "INTERNAL FUNCTIONS used to write derivated parsers"
.IX Header "INTERNAL FUNCTIONS used to write derivated parsers"
.Sh "Getting input, providing output"
.IX Subsection "Getting input, providing output"
Four functions are provided to get input and return output. They are very
similar to shift/unshift and push/pop. The first pair is about input, while
the second is about output. Mnemonic: in input, you are interested in the
first line, what shift gives, and in output you want to add your result at
the end, like push does.
.IP "\fIshiftline()\fR" 4
.IX Item "shiftline()"
This function returns the next line of the doc_in to be parsed and its
reference (packed as an array).
.IP "unshiftline($$)" 4
.IX Item "unshiftline($$)"
Unshifts a line of the input document and its reference.
.IP "pushline($)" 4
.IX Item "pushline($)"
Push a new line to the doc_out.
.IP "\fIpopline()\fR" 4
.IX Item "popline()"
Pop the last pushed line from the doc_out.
.Sh "Marking strings as translatable"
.IX Subsection "Marking strings as translatable"
One function is provided to handle the text which should be translated.
.IP "translate($$$)" 4
.IX Item "translate($$$)"
Mandatory arguments:
.RS 4
.IP "\-" 2
A string to translate
.IP "\-" 2
The reference of this string (i.e. position in inputfile)
.IP "\-" 2
The type of this string (i.e. the textual description of its structural role;
used in \fILocale::Po4a::Po::gettextization()\fR; see also \fIpo4a\fR\|(7),
section \fBGettextization: how does it work?\fR)
.RE
.RS 4
.Sp
This function can also take some extra arguments. They must be organized as
a hash. For example:
.Sp
.Vb 2
\&  $self\->translate("string","ref","type",
\&                   \*(Aqwrap\*(Aq => 1);
.Ve
.IP "\fBwrap\fR" 4
.IX Item "wrap"
boolean indicating whether we can consider that whitespaces in string are
not important. If yes, the function canonizes the string before looking for
a translation or extracting it, and wraps the translation.
.IP "\fBwrapcol\fR" 4
.IX Item "wrapcol"
the column at which we should wrap (default: 76).
.IP "\fBcomment\fR" 4
.IX Item "comment"
an extra comment to add to the entry.
.RE
.RS 4
.Sp
Actions:
.IP "\-" 2
Pushes the string, reference and type to po_out.
.IP "\-" 2
Returns the translation of the string (as found in po_in) so that the
parser can build the doc_out.
.IP "\-" 2
Handles the charsets to recode the strings before sending them to
po_out and before returning the translations.
.RE
.RS 4
.RE
.Sh "Misc functions"
.IX Subsection "Misc functions"
.IP "\fIverbose()\fR" 4
.IX Item "verbose()"
Returns if the verbose option was passed during the creation of the
TransTractor.
.IP "\fIdebug()\fR" 4
.IX Item "debug()"
Returns if the debug option was passed during the creation of the
TransTractor.
.IP "detected_charset($)" 4
.IX Item "detected_charset($)"
This tells TransTractor that a new charset (the first argument) has been
detected from the input document. It can usually be read from the document
header. Only the first charset will remain, coming either from the
\&\fIprocess()\fR arguments or detected from the document.
.IP "\fIget_out_charset()\fR" 4
.IX Item "get_out_charset()"
This function will return the charset that should be used in the output
document (usually useful to substitute the input document's detected charset
where it has been found).
.Sp
It will use the output charset specified in the command line. If it wasn't
specified, it will use the input \s-1PO\s0's charset, and if the input \s-1PO\s0 has the
default \*(L"\s-1CHARSET\s0\*(R", it will return the input document's charset, so that no
encoding is performed.
.IP "recode_skipped_text($)" 4
.IX Item "recode_skipped_text($)"
This function returns the recoded text passed as argument, from the input
document's charset to the output document's one. This isn't needed when
translating a string (\fItranslate()\fR recodes everything itself), but it is when
you skip a string from the input document and you want the output document to
be consistent with the global encoding.
.SH "FUTURE DIRECTIONS"
.IX Header "FUTURE DIRECTIONS"
One shortcoming of the current TransTractor is that it can't handle
translated document containing all languages, like debconf templates, or
\&.desktop files.
.PP
To address this problem, the only interface changes needed are:
.IP "\-" 2
take a hash as po_in_name (a list per language)
.IP "\-" 2
add an argument to translate to indicate the target language
.IP "\-" 2
make a pushline_all function, which would make pushline of its content for
all language, using a map-like syntax:
.Sp
.Vb 3
\&    $self\->pushline_all({ "Description[".$langcode."]=".
\&                          $self\->translate($line,$ref,$langcode)
\&                        });
.Ve
.PP
Will see if it's enough ;)
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 3
\& Denis Barbier <barbier@linuxfr.org>
\& Martin Quinson (mquinson#debian.org)
\& Jordi Vilalta <jvprat@gmail.com>
.Ve
